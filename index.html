<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Writing fast Python</title>
        <meta name="description" content="Presentation about source code level optimizations for Python">
        <meta name="author" content="Sebastian Witowski">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">

        <!-- Reveal.js theme -->
        <link rel="stylesheet" href="css/theme/blood.css">
        <!-- Custom CSS rules -->
        <link rel="stylesheet" href="css/custom.css">
        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/gruvbox-dark.css">
        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <!-- Vertical slides for different title variations -->
                    <section>
                        <h1>Writing faster code</h1>
                        <aside class="notes">
                            Hi everyone.<br>
                            I would like to talk with you about writing faster code. Last time I gave a short talk on how to make your Python code faster, I remember someone pointing out that 'basically you can rewrite your code in C to make it faster'.<br>
                            And you know what ? The guy was absolutely right. Take any piece of code, rewrite it in C or C++ and it will be automatically faster.<br>
                            So I was thinking, "Hmm, if I say just 'writing faster code', people will be confused if it's only about Python or not".<br>
                            So I decided to fix it.<br>
                        </aside>
                    </section>
                    <section>
                        <h2>Writing faster code <span class='orange'>and not hating your job as a software developer</span></h2>
                        <aside class="notes">
                            I was very happy with the new title. It makes it clear that we are not talking about Java or C here.<br>
                            But then I remembered from school that the presentation title should be clear but also concise.
                            And frankly - this one barely even fits on the slides.<br>
                            So I had to fix it again.<br>
                        </aside>
                    </section>
                    <section>
                        <h1>Writing faster <span class='orange'>Python</span></h1>
                        <aside class="notes">
                            And this is how I ended up with 'Writing faster Python' as a title for my today's talk.
                            Let's put aside the flame war about which programming language is better.<br>
                            (Whisper) We all know the answer, that's why you are here!(/Whisper)
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Python was not made to be fast...</h4>
                        <h4>...but to make developers fast.</h4>
                        <aside class="notes">
                            Python was not created to be a fast language that you would use for LHC computations where every nanosecond counts.<br>
                            And that's fine with me. Python is a great programming language that is easy and fun to use.<br>
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <div class="blockquote">
                            <blockquote>
                                <p>It was nice to learn Python;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
                                a nice afternoon</p>
                            </blockquote>
                            <div class="blockquote-attribution">
                                <p class="blockquote-author">
                                    Donald Knuth
                                </p>
                                <div class="blockquote-picture knuth"></div>
                            </div>
                        </div>
                        <aside class="notes">
                            Python is very easy to learn. The fact that it's so easy to read and write code in Python is very encouraging for people new to development.<br>
                            I see that it's getting more and more popular in schools or universities as the first programming language that people are learning.<br>
                        </aside>
                    </section>
                    <section>
                        <p>Would you like your FIRST program EVER to be like:<br><br></p>
                        <pre><code class='python' data-trim data-noescape>
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
                        </code></pre>
                        <p>or</p>
                        <pre><code class='python' data-trim data-noescape>
print("Hello, world!")
                        </code></pre>
                        <aside class="notes">
                            And I'm not surprised. I mean, imagine you are completely new to programming and someone tells you: "Hey, let me show you how much fun programming is. Let's start with something super simple and write some text to the screen."<br>
                            And then he shows you one of those examples.<br>
                            I mean, one of them is clearly not something that you would show to a beginner to encourage him or her to start programming.
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img class="no-borders" src="./img/logos.png">
                        <p></p>
                        <small class='source-link'>Source: <a href="">https://www.shoop.io/en/blog/25-of-the-most-popular-python-and-django-websites</a></small>
                        <aside class="notes">
                            So, is Python only usefull for learning programming ?
                            Nope, and as a proof of that, here are some big companies that are quite happy with using Python as their backend or parts of their backend.
                            Those are companies with millions of users and billions of requests, so I think your website website will also be fine with using Python.
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h1 class='h1-smaller'>OPTIMIZATION</h1>
                        <aside class="notes">
                            So Python is usually fast enough. But what if we decide it's not fast enough anymore.<br>
                            For example, your websites starts giving timeouts to your users or maybe a faster code will bring more money for your company (or more data for your physicists).<br>
                            It's time for optimization!
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img src="./img/google-optimization.png">
                        <aside class="notes">
                            But how do you optimize your code ?<br>
                            Probably you need to follow some rules, so let's try to google that.<br>
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img src="./img/optimization-rules.png">
                        <aside class="notes">
                            Let's open the first link.<br>
                            Only 3 rules ? Wow, optimization might be easier than we expected!
                            Let's take a closer look at those rules.
                        </aside>
                    </section>
                    <section>
                        <h3>Don't</h3>
                        <h3 class="fragment">Don't...&nbsp;yet</h3>
                        <ul class="fragment current-visible remove" style="padding-left:325px;">
                            <li>Finish your code</li>
                            <li>Have tests</li>
                            <li>Now</li>
                        </ul>
                        <h3 class="fragment">Profile</h3>
                        <ul class="fragment current-visible remove" style="padding-left:325px;">
                            <li>cProfile</li>
                            <li>pstats</li>
                            <li>RunSnakeRun, SnakeViz</li>
                        </ul>
                        <aside class="notes">
                            First rule of optimization: Don't. Ok, that was easy. Thank you for your attention.<br>
                            Well, actually now, there is more.<br>
                            So what does it mean 'Don't.<br>
                            Well, 9 out of 10 times when you think you need optimization, you don't, especially in the early stage of your product's life.<br>
                            You might think it would be nice to optimize your code a bit, but first of all, you will waste time doing something that is not needed. You can get more benefits from getting a faster hardware of something if you want. Second of all, optimization comes with a cost. Sometimes it's only the time spend optimizing existing code. Sometimes you have to add even more time to fix, what you broke with you optimization. But also, the optimized code might not be as readable as it was in the first place. And maybe your code is running faster but uses more memory ? So unless you have real resons to optimize - don't do this.
                            If you know that you really need to optimize, then you can move to the second rule of optimization - don't do this yet. This is how I understand it:<br>
                            First make sure your code works<br>
                            Then make sure you have good test suite<br>
                            And only then, you are ready for optimization.<br>
                            I love this rule, it always reminds me how many times I have violated it. So many times I was in the middle of working on a more or less complex piece of code and then I started thinking: "Hmm, I can change that piece of code and probably it will be faster - also I will save 2 lines of code".<br>
                            Was it a good idea ?<br>
                            Nope. And not only because I ended up breaking things. Well, quite often I did end up breaking things, but also, when I started jumping around the code, I forgot what exactly was I writing in the first place.<br>
                            One way or another, it was causing confusion and additional work.<br>
                            Did it make my code faster ?<br>
                            I have no idea, because I had nothing to compare it to! If I had written the whole function first and then improve it, I could measure it and see if it's better or worse now, but otherwise I could only guess.<br>
                            And that brings me to the last rules of optimization - Don't guess.<br>
                            Always profile your code before optimization. Human are terrible in predicting bottlenecks of the code. If you code is slow - profile it and see what takes the most time. Otherwise, you might end up spending time to rewrite part of your code just to make it 1% faster, while there are other parts of the system where you can gain much more improvements with less effort.
                            There are plenty of profiling tools, if you don't know where to start, you can try the built-in Python profiler called cProfile.<br>
                            It will show you a clear overview of how many times each function is called and where is your code spending most of the time, so there is no need to guess.<br>
                            You can combine it with the pstats module, which allows for more advanced formatting of the results.<br>
                            If you prefer a graphical interface, there are also libraries like that. RunSnakeRun and SnakeViz seems to be the most common.
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Levels of optimization</h3>
                        <ul>
                            <li class="fragment">Design</li>
                            <li class="fragment">Algorithms and data structures</li>
                        </ul>
                        <aside class="notes">
                            Once we are ready for optimization, we have to decide, on which area we want to focus.<br>
                            There are different levels of optimization:<br>
                            Starting from the highest level, you have the design level optimization. Depending on the constrains and priorities of your system, you can optimize it by redesigning it. It might require rewriting parts or the whole application in a different programming language that might be faster, changing the type of a database or redesigning the architecture of your software to limit the number of DB queries etc.<br>
                            We are probably not interested in this kind of optimization today, as we are not going to rewrite something that we have been working very hard on in the past months or years. However, if you have some critical parts of the code that are run often, you can optimize it by rewriting it in C or C++. Because C is faster, you can get some good speed improvement for free. Well, not really for free - now you have to maintain Python AND C/C++ code in one project.

                            One level lower, we have algorithms and data structures. That's usually the second biggest improvement you can get after a complete redesign. Knowing different algorithms together with their complexity definitely helps creating good, fast software.
                        </aside>
                    </section>
                    <section>
                        <pre><code class='python' data-trim data-noescape>
sum = 0
for x in range(1, N + 1):
    sum += x
print sum
                        </pre></code>
                        <div class="fragment">
                            <p class="arrow">&#8595;</p>
                            <pre><code class='python' data-trim data-noescape>
print N * (1 + N) / 2
                            </pre></code>
                        </div>
                        <aside class="notes">
                            For example, you want to get a sum of numbers from 1 to N. The first idea might be a loop that goes though all elements and adds them.<br>
                            It will work, but it won't be fast.<br>
                            You can instead use an algorithm for the arithmetic sum, which will give you the same results and it will be more efficient.
                        </aside>
                    </section>
                    <section>
                        <h3>Levels of optimization</h3>
                        <ul>
                            <li>Design</li>
                            <li>Algorithms and data structures</li>
                            <li>Source code</li>
                            <li class="fragment">Build level</li>
                            <li class="fragment">Compile level</li>
                            <li class="fragment">Assembly level</li>
                            <li class="fragment">Runtime level</li>
                        </ul>
                        <aside class="notes">
                            Next level is the source code optimization. This is something that I want to talk about today. We are slowly getting there.

                            And now we got to the low levels of optimization. For example, "build level" involves setting up specific build flags. In you daily work, it's not something that you do often. You can optimize Python for a specific architecture, but if you are a web-developer like me, you don't go to that level of optimization.

                            Compile level - you can make some optimizations if you are using Ahead of Time compiler. Which is not the case for Python, as there is no ahead of time compiler for Python.

                            Assembly level - this is probably as low as you can get with the optimization. For additional performance, you can write directly the assembly code for a specific architecture. As this is "Python Developers Forum", not the "Assembly Developers Forum", I will not focus on this level of optimization either.

                            Last but not least - runtime level. It's related with a specific compiler you are using. Some compilers are faster than the others, for example if you replace CPython with PyPy, you can gain on average up to 7 times speed improvement, but again, it depends on what kind of task you are doing.<br>
                            Most of the time, once we set up on a specific language implementation, there is nothing we have to do to benefit from this kind of optimizations - it's up to the creators of the compilers to optimize them, so simply updating to the new version of the programming language you are using can make your programs run a bit faster.
                        </aside>
                    </section>
                </section>
                <!-- Optimization is not only the speed -->
                <section>
                    <section>
                        <h4>Optimization is all about the speed</h4>
                        <div class="fragment">
                            <h4>... and memory</h4>
                        </div>
                        <div class="fragment">
                            <h4>... and disk space</h4>
                            <h4>... disk I/O</h4>
                            <h4>... network I/O</h4>
                            <h4>... power consumption</h4>
                            <h4>... and more.</h4>
                        </div>
                        <aside class="notes">
                            So, when you optimize you probably want your code to run faster.<br>
                            And also use less memory. And less disk space, perform less disk I/O, network I/O, less power consumption, etc. etc.
                            The bad news is - you can't have all of this. Optimization in one area will usuallycause deterioration in other areas.
                            So you have to always decide, which resources are crucial to you and try to optimize in that direction.
                            So it's possible that optimization will have nothing to do with the execution time at all, as there can be other resources more important than the raw speed.
                            For example, who cares if you program is now 10 times faster if it's crashing half of the time, because it's running out of memory ?
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <div class="blockquote">
                            <blockquote>
                                <p>Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live</p>
                            </blockquote>
                            <div class="blockquote-attribution">
                                <p class="blockquote-author">
                                    John Woods
                                </p>
                            </div>
                        </div>
                        <aside class="notes">
                            Another important resource of optimization that people are often forgetting is sanity.<br>
                            Sanity of a person, who will be maintaining your code. So please, be nice to that person, you never know who that might be.<br>
                            Unless you are really writing a throw-away code, if you are making the code harder to read and maintain, then you are probably doing it wrong!
                        </aside>
                    </section>
                </section>
                <!-- SOURCE CODE OPTIMIZATION -->
                <section>
                    <section>
                        <h2>Writing fast Python</h2>
                        <h5>a.k.a source code optimization</h5>
                        <aside class="notes">
                            Having those things cleared, let's jump straight to how you can write faster Python, also known as source code optimization.<br>
                        </aside>
                    </section>
                    <section>
                        <h5>%timeit</h5>
                        <pre><code class='python' data-trim data-noescape>
def ultimate_answer_of_life():
    return 42
                        </pre></code>
                        <pre><code class='python' data-trim data-noescape>
>>> %timeit ultimate_answer_of_life()
10000000 loops, best of 3: 87.1 ns per loop
                        </pre></code>
                        <p class="source-link">
                            2.72 × 10<sup>21</sup> times faster than in <a href="https://en.wikipedia.org/wiki/42_(number)#Hitchhiker.27s_Guide_to_the_Galaxy">The Hitchhiker's Guide to the Galaxy</a>
                        </p>
                        <aside class="notes">
                            In my examples, I have used the magic %timeit function that comes with IPython. It has some overhead comparing with the standard timeit library, but it doesn't really matter - as long as we use the same method to measure execution time of different functions, we only need to know which method is faster and by how much.<br>
                            So for each of my example, I write different versions of code, measure the execution time and compare them.
                        </aside>
                    </section>
                </section>
                <!-- Counting elements in a list -->
                <section>
                <h4><span class="orange">#</span> Count elements in a list</h4>
                    <pre><code class='python'># SLOW
how_many = 0
for element in BIG_LIST:
    how_many += 1
print how_many</pre></code>
                            <pre><code class='python'># FAST
print len(BIG_LIST)</pre></code>
                    <p>
                        For 1 000 000 elements it's <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        The fast version is <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        Let's start with something simple. Let's say you want to count a number of elements in a list. You can easily write a simple loop than increments a counter and there is nothing wrong with this code, except that it's slow. You can achieve the same results using the built-in function len(). And as you can see the speed improvement is quite huge.
                        So, try to use the built-in functions and functions from the standard library when you can.
                        <<< ADD a separate slide with the list of python 3.5.1 built-ins >>>
                        Python 3.5.1 contains 68 built-in variables [source](https://docs.python.org/3.5/library/functions.html) - you won't need all of them (I don't remember when was the list time - if ever - I used (xxx - find function names here), but it will take you just a moment to take a look at that list from time to time and keep it in the back of your head.
                    </aside>
                </section>
                <!-- Checking for True -->
                <section>
                <h4><span class="orange">#</span> Checking for True</h4>
                    <pre><code class='python' data-trim data-noescape>
if variable == True:
                    </pre></code>
                    <p>
                        <span class="bad">35.8 ns</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
if variable is True:
                    </pre></code>
                    <p>
                        <span class="bad">28.7 ns</span><br>
                        1.24 times faster
                    </p>
                    <pre><code class='python' data-trim data-noescape>
if variable:
                    </pre></code>
                    <p>
                        <span class="good">20.6 ns</span><br>
                        1.73 times faster
                    </p>
                    <aside class="notes">
                        Let's say you want to check if some variable or an expression is true. You can explicitly compare this variable to True, but unless you really want to check if a variable is really True (and not 0 or None)  you can simplify your condition to just 'if variable'. It will return True, unless the variable is False, None, 0, empty string, empty list or any other "Falsy" expression. And by doing that, your instruction get almost twice faster.
                    </aside>
                </section>
                <!-- Checking for False -->
                <section>
                <h4><span class="orange">#</span> Checking for False</h4>
                    <pre><code class='python' data-trim data-noescape>
if variable == False:
                    </pre></code>
                    <p>
                        <span class="bad">35.1 ns</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
if variable is False:
                    </pre></code>
                    <p>
                        <span class="bad">26.9 ns</span><br>
                        1.30 times faster
                    </p>
                    <pre><code class='python' data-trim data-noescape>
if not variable:
                    </pre></code>
                    <p>
                        <span class="good">19.8 ns</span><br>
                        1.77 times faster
                    </p>
                    <aside class="notes">
                        The same rule applies when checking for False, the fastest way to do this is to use 'if not variable', unless you really need to distinguish False from None, 0 or other Falsy values.
                    </aside>
                </section>
                <!-- Ask for permissions vs beg for forgiveness -->
                <section>
                <h4><span class="orange">#</span> Ask for permissions vs beg for forgiveness</h4>
                    <pre><code class='python' data-trim data-noescape>
class Foo(object):
    hello = 'world'
foo = Foo()
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
if hasattr(foo, 'hello'):
    foo.hello
                    </pre></code>
                    <p>
                        <span class="bad">149 ns</span><br>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
try:
    foo.hello
except AttributeError:
    pass
                    </pre></code>
                    <p>
                        <span class="good">43.1 ns</span><br>
                        3.5 times faster
                    </p>
                    <aside class="notes">
                        When you want to execute a piece of code, but you are not sure it will be successful (maybe some variables are not set or maybe performing a specific operation will throw as exception), so you want to protect yourself somehow. The first way you can do this is called 'Look before you leap' or ask for permission. What is means is that you check if all variables are set and everything is fine and then you perform you operations. Usually this checking is performed with the if statement.
                        However, there is a different approach that you could use - it's called "Beg for forgiveness". In this scenario, you perform your operation without checking the conditions, but in case you expect that something might break, you wrap you code in try/except block and catch the exceptions that were raised.
                        As you can see in this example, begging for forgiveness is 3,5 times faster.
                    </aside>
                </section>
                <!-- Ask for permissions vs beg for forgiveness 2 -->
                <section>
                <h4><span class="orange">#</span> Ask for permissions vs beg for forgiveness</h4>
                    <pre><code class='python' data-trim data-noescape>
if (hasattr(foo, 'foo') and hasattr(foo, 'bar')
    and hasattr(foo, 'baz')):
    foo.foo
    foo.bar
    foo.baz
                    </pre></code>
                    <p>
                        vs
                    </p>
                    <pre><code class='python' data-trim data-noescape>
try:
    foo.foo
    foo.bar
    foo.baz
except AttributeError:
    pass
                    </pre></code>
                    <p>
                        <span class="bad">401 ns</span> vs <span class="good">110 ns</span><br>
                        3.64 times faster
                    </p>
                    <aside class="notes">
                        But it gets even better if you are checking for more conditions.
                        Here, we are checking if 3 attributes are available. Asking for permissions is still slower and now it gets more difficult to read.
                        Following the beg for forgiveness principle will result in faster and more readable code
                        So, is asking for forgiveness instead of checking the permissions always the best choice ?
                    </aside>
                </section>
                <!-- Ask for permissions vs beg for forgiveness 3 -->
                <section>
                <h4><span class="orange">#</span> Ask for permissions vs beg for forgiveness</h4>
                    <pre><code class='python' data-trim data-noescape>
class Bar(object):
    pass
bar = Bar()
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
if hasattr(bar, 'hello'):
    bar.hello
                    </pre></code>
                    <p>
                        <span class="good">428 ns</span><br>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
try:
    bar.hello
except AttributeError:
    pass
                    </pre></code>
                    <p>
                        <span class="bad">536 ns</span><br>
                        25% slower
                    </p>
                    <aside class="notes">
                        Well, not really. The exception handling is still quite expensive performance wise.
                        If the object doesn't have the attribute we are looking for, begging for forgiveness will be slower than asking for permissions.
                        So as a rule of thumb, you can use the 'Ask for permissions' way if you know that it's very probably that there will be some uninitialized variables or other problems.
                        Otherwise if you are expecting your code to run smoothly most of the time (for example, you are fetching some files from the internet and you are expecting that it will work, unless there is no internet connection) using try/except will be the faster and quite often cleaner way to go.
                        But again, I strongly advise you to measure both solutions to see which one is faster in your scenario.
                    </aside>
                </section>
                <!-- Ask for permissions vs beg for forgiveness 4 -->
                <section>
                <h4><span class="orange">#</span> Ask for permissions vs beg for forgiveness</h4>
                    <p>Find an example of using dict.get() function to best faster and better than ask for forgiveness/permissions</p>
                    <aside class="notes">
                        Quite common use case for this kind of lookup happens with the dictionaries. Let's say we have a dictionary containing square value of the first 1 million numbers. For an arbitrary number, we want to get it's square value or empty string, if there is no emtry in our dictionary.
                        As you can see, begging for forgiveness is almost twice faster than asking for permission.
                        But we can do better than this. Dictionaries have a get method, that you should use in a case like that.
                    </aside>
                </section>
                <!-- END Execute operation 1000 times in a function than a function 1000 times -->
                <section>
                <h4><span class="orange">#</span> Execute function 1000 times or execute an operation 1000 times in a function ?</h4>
                    <pre><code class='python' data-trim data-noescape>
def square(number):
    return number**2
squares = [square(i) for i in range(1000)]
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
def compute_squares():
    return [i**2 for i in range(1000)]
                    </pre></code>
                    <p>
                        <span class="bad">399 µs</span> vs <span class="good">314 µs</span><br>
                         27% faster
                    </p>
                    <aside class="notes">
                        If you want to perform some kind of operation on a large set of data, your first idea might be to write a function that performs said operation and then apply this function on the set of data. However, it's faster to perform those 1000 operations inside a function instead of calling a function 1000 times.
                    </aside>
                </section>
                <!-- Create a string from a list -->
                <section>
                <h4><span class="orange">#</span> Create a string from a list</h4>
                    <pre><code class='python' data-trim data-noescape>
# Create a list of 1000 words:
LIST = ['word'] * 1000
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
result = ''
for word in LIST:
    result += word
                    </pre></code>
                    <p>vs</p>
                    <pre><code class='python' data-trim data-noescape>
result = ''.join(LIST)
                    </pre></code>
                    <p>
                        10000 loops, best of 3: 94 µs per loop
                        100000 loops, best of 3: 8.54 µs per loop

                        <span class="bad">94 µs</span> vs <span class="good">8.54 µs</span><br>
                        11 times faster
                    </p>
                    <aside class="notes">
                        Let's talk about string for now. If you have a list of strings and want to concatenate them into one string, using a loop is not the best idea. Instead, you can use the join function, that will be much faster (and clearer to understand). Here, for a list of 1000 words, the join function is 11 times faster. I have also tested it with longer words and even though the difference got lower (for 1000 words of 600 characters, join was 'only' twice as fast), join function is still a clear winner here.
                    </aside>
                </section>
                <!-- String formatting is faster than string concatenation -->
                <section>
                <h4><span class="orange">#</span> String formatting or string concatenation ?</h4>
                <h2>This is not working, find better example: https://wiki.python.org/moin/PythonSpeed/PerformanceTips#String_Concatenation</h2>
                    <pre><code class='python' data-trim data-noescape>
word1 = 'Hello'
word2 = 'world'
word3 = 'from'
word4 = 'EuroPython'
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
"This is:" + word1 + word2 + word3 + word4 + "!"
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
"This is:%s%s%s%s!" % (word1, word2, word3, word4)

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                    1000000 loops, best of 3: 369 ns per loop

                        In case you are trying to concatenate just a few strings, not a whole list, you are also better of with using string formatting, instead of concatenation operator.
                    </aside>
                </section>
                <!-- List sorting is faster in place -->
                <section>
                <h4><span class="orange">#</span> List sorting</h4>
                    <pre><code class='python' data-trim data-noescape># SETUP
alist = [random.randint(1,100) for _ in range(1000000)]
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        List sorting is faster when you do this in place with list.sort() instead of calling sorted method on a list.
                    </aside>
                </section>
                <!-- Filter a list -->
                <section>
                <h4><span class="orange">#</span> Filter list</h4>
                    <pre><code class='python' data-trim data-noescape>
# SLOW
output = []
for element in MILLION_ELEMENTS:
    if element % 2:
        output.append(element)
                    </pre></code>
                    <p>
                        <span class="bad">107 ms</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
# FAST?
list(filter(lambda x: x % 2, MILLION_ELEMENTS))
                    </pre></code>
                    <p>
                        <span class="bad">168 ms</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
# FAST!
[item for item in MILLION_ELEMENTS if item % 2]
                    </pre></code>
                    <p>
                        <span class="good">80.9 ms</span>
                    </p>
                    <p>
                        35% faster
                    </p>
                    <aside class="notes">
                        Let's say you want to filter a list of 1 million elements and select only those, that are matching some condition.
                        The naive version would be to use for loop, but I already showed you that in most cases, for loops are bad.
                        You can use the built-in filter function instead. In Python2, filter was returning the list directly. In Python3, it's returning an iterator, so I need to explicitly convert the results of filter function to a list to get the same results as in case of the loop.
                        This conversion impacts the performance, but even without some overhead for list function, you can see that filter performs much slower.
                        Why does this happen ? Well, the fact that filter is now returning an iterator is a good suggestion that this is a wrong use case for filter function.
                        If we want to get the whole list as a result, the better idea is to use list comprehension. It's around 35% faster than the for loop and - at least for me - it looks much better.
                    </aside>
                </section>
                <!-- Lambda vs def -->
                <section>
                <h4><span class="orange">#</span> Lambda vs def</h4>
                    <p>Def:</p>
                    <pre><code class='python' data-trim data-noescape>
def greet_def(name):
    return 'Hello {}!'.format(name)
                    </pre></code>
                    <p>Lambda:</p>
                    <pre><code class='python' data-trim data-noescape>
greet_l = lambda name: 'Hello {}!'.format(name)
                    </pre></code>
                    <p>Compare:</p>
                    <pre><code class='python' data-trim data-noescape>
>>> %timeit greet_def('Tom')
1000000 loops, best of 3: 329 ns per loop
>>> %timeit greet_l('Tom')
1000000 loops, best of 3: 332 ns per loop
                    </pre></code>
                    <aside class="notes">
                        Let's take a look at different ways of defining functions in Python. The most common way to create a function is with def keyword. The other way is to declare an anonymous function with lambda. If you assign this lambda to a variable it will act in the same way as function created with def keyword.
                        So let's see which version is faster.
                        Well, actually they are both equally fast.
                        Why ? Because both version exactly the same thing.
                        We can see that even better when disassembling the code of both function.
                    </aside>
                </section>
                <!-- Lambda vs def contd.-->
                <section>
                <h4><span class="orange">#</span> Lambda vs def</h4>
                    <pre><code class='python' data-trim data-noescape>
>>> dis.dis(greet_def)
 0 LOAD_CONST    1 ('Hello {}!')
 3 LOAD_ATTR     0 (format)
 6 LOAD_FAST     0 (name)
 9 CALL_FUNCTION 1 (1 positional, 0 keyword pair)
12 RETURN_VALUE
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
>>> dis.dis(greet_l)
 0 LOAD_CONST    1 ('Hello {}!')
 3 LOAD_ATTR     0 (format)
 6 LOAD_FAST     0 (name)
 9 CALL_FUNCTION 1 (1 positional, 0 keyword pair)
12 RETURN_VALUE
                    </pre></code>
                    <small><a href='http://stackoverflow.com/questions/29804774/why-is-lambda-expression-necessary-in-this-example-python'>Stack Overflow on when lambda might be necessary</a></small>
                    <aside class="notes">
                        So is there any difference ?
                        Well, if your function has more than one line, then you can't use lambda.
                        Also, you can't really put documentation inside lambda function.
                        And if you have PEP-8 enabled in you code editor, it will complain each time you try to assign lambda to a variable.
                        And he is right, lambda works really nice when you need a simple one-liner callback for functions, especially for functions like filter, map or reduce.
                        There are also some quite narrow use cases when it might be necessary to use the lambda instead of def as a callback - if you want to read more, I'm linking a stack overflow question with that problem.
                        However, for any other case, I would use def. It's much cleaner, you can document it properly and the performance is the same.
                    </aside>
                </section>
                <!-- [] vs list() and {} vs dict() -->
                <section>
                <h4><span class="orange"></span>[] and {}</h4>
                    <div>
                        <div class='left'>
                            <pre><code class='python' data-trim data-noescape>
list()
                            </pre></code>
                            <p>
                                <span class="bad">104 ns</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>
[]
                            </pre></code>
                            <p>
                                <span class="good">22.5 ns</span>
                            </p>
                            <p>
                                4.6 times faster
                            </p>
                        </div>
                        <div class='right'>
                            <pre><code class='python' data-trim data-noescape>
dict()
                            </pre></code>
                            <p>
                                <span class="bad">161 ns</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>
{}
                            </pre></code>
                            <p>
                                <span class="good">93 ns</span>
                            </p>
                            <p>
                                1.7 times faster
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        There are 2 ways you can create an empty list or a dictionary. You can either call a function for that, or you can simply use the literal syntax.
                        As you can see, using the literal syntax is way faster.
                        Let's take a quick look, why this happens.
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- Attributions -->
                <section>
                <h4><span class="orange">#</span> Attributions</h4>
                    <ul>
                        <li>Donald Knuth at a reception for the Open Content Alliance, hosted by the Internet Archive. Taken October 25, 2005 by Jacob Appelbaum in San Francisco.</li>
                    </ul>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- SPLIT DIV -->
                <section>
                <h4><span class="orange">#</span> SPLIT DIV </h4>
                    <div>
                        <div class='left'>
                            <pre><code class='python' data-trim data-noescape>

                            </pre></code>
                            <p>
                                <span class="bad">xxxxxx</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>

                            </pre></code>
                            <p>
                                <span class="good">xxxxxx</span>
                            </p>
                            <p>
                                xxxxxxxxx
                            </p>
                        </div>
                        <div class='right'>
                            <pre><code class='python' data-trim data-noescape>

                            </pre></code>
                            <p>
                                <span class="bad">xxxxxxxx</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>

                            </pre></code>
                            <p>
                                <span class="good">xxxxxxxx</span>
                            </p>
                            <p>
                                xxxxxxxxxx
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,
                slideNumber: 'c/t',

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
