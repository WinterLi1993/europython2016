<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Writing fast Python</title>
        <meta name="description" content="Presentation about source code level optimizations for Python">
        <meta name="author" content="Sebastian Witowski">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">

        <!-- Reveal.js theme -->
        <link rel="stylesheet" href="css/theme/blood.css">
        <!-- Custom CSS rules -->
        <link rel="stylesheet" href="css/custom.css">
        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/gruvbox-dark.css">
        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <!-- Vertical slides for different title variations -->
                    <section>
                        <h1>Writing faster code</h1>
                        <aside class="notes">
                            Hi everyone.<br>
                            I would like to talk with you about writing faster code. Last time I gave a short talk on how to make your Python code faster, I remember someone pointing out that 'basically you can rewrite your code in C to make it faster'.<br>
                            And you know what ? The guy was absolutely right. Take any piece of code, rewrite it in C or C++ and it will be automatically faster.<br>
                            So I was thinking, "Hmm, if I say just 'writing faster code', people will be confused if it's only about Python or not".<br>
                            So I decided to fix it.<br>
                        </aside>
                    </section>
                    <section>
                        <h2>Writing faster code <span class='orange'>and not hating your job as a software developer</span></h2>
                        <aside class="notes">
                            I was very happy with the new title. It makes it clear that we are not talking about Java or C here.<br>
                            But then I remembered from school that the presentation title should be clear but also concise.
                            And frankly - this one barely even fits on the slides.<br>
                            So I had to fix it again.<br>
                        </aside>
                    </section>
                    <section>
                        <h1>Writing faster <span class='orange'>Python</span></h1>
                        <aside class="notes">
                            And this is how I ended up with 'Writing faster Python' as a title for my today's talk.
                            Let's put aside the flame war about which programming language is better.<br>
                            (Whisper) We all know the answer, that's why you are here!(/Whisper)
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Python was not made to be fast...</h4>
                        <h4>...but to make developers fast.</h4>
                        <aside class="notes">
                            Python was not created to be a fast language that you would use for LHC computations where every nanosecond counts.<br>
                            And that's fine with me. Python is a great programming language that is easy and fun to use.<br>
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <div class="blockquote">
                            <blockquote>
                                <p>It was nice to learn Python;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
                                a nice afternoon</p>
                            </blockquote>
                            <div class="blockquote-attribution">
                                <p class="blockquote-author">
                                    Donald Knuth
                                </p>
                                <div class="blockquote-picture knuth"></div>
                            </div>
                        </div>
                        <aside class="notes">
                            Python is very easy to learn. The fact that it's so easy to read and write code in Python is very encouraging for people new to development.<br>
                            I see that it's getting more and more popular in schools or universities as the first programming language that people are learning.<br>
                        </aside>
                    </section>
                    <section>
                        <p>Would you like your FIRST program EVER to be like:<br><br></p>
                        <pre><code class='python' data-trim data-noescape>
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
                        </code></pre>
                        <p>or</p>
                        <pre><code class='python' data-trim data-noescape>
print("Hello, world!")
                        </code></pre>
                        <aside class="notes">
                            And I'm not surprised. I mean, imagine you are completely new to programming and someone tells you: "Hey, let me show you how much fun programming is. Let's start with something super simple and write some text to the screen."<br>
                            And then he shows you one of those examples.<br>
                            I mean, one of them is clearly not something that you would show to a beginner to encourage him or her to start programming.
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img class="no-borders" src="./img/logos.png">
                        <p></p>
                        <small class='source-link'>Source: <a href="">https://www.shoop.io/en/blog/25-of-the-most-popular-python-and-django-websites</a></small>
                        <aside class="notes">
                            So, is Python only usefull for learning programming ?
                            Nope, and as a proof of that, here are some big companies that are quite happy with using Python as their backend or parts of their backend.
                            Those are companies with millions of users and billions of requests, so I think your website website will also be fine with using Python.
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h1 class='h1-smaller'>OPTIMIZATION</h1>
                        <aside class="notes">
                            So Python is usually fast enough. But what if we decide it's not fast enough anymore.<br>
                            For example, your websites starts giving timeouts to your users or maybe a faster code will bring more money for your company (or more data for your physicists).<br>
                            It's time for optimization!
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img src="./img/google-optimization.png">
                        <aside class="notes">
                            But how do you optimize your code ?<br>
                            Probably you need to follow some rules, so let's try to google that.<br>
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img src="./img/optimization-rules.png">
                        <aside class="notes">
                            Let's open the first link.<br>
                            Only 3 rules ? Wow, optimization might be easier than we expected!
                            Let's take a closer look at those rules.
                        </aside>
                    </section>
                    <section>
                        <h3>Don't</h3>
                        <h3 class="fragment">Don't...&nbsp;yet</h3>
                        <ul class="fragment current-visible remove" style="padding-left:325px;">
                            <li>Finish your code</li>
                            <li>Have tests</li>
                            <li>Now</li>
                        </ul>
                        <h3 class="fragment">Profile</h3>
                        <ul class="fragment current-visible remove" style="padding-left:325px;">
                            <li>cProfile</li>
                            <li>pstats</li>
                            <li>RunSnakeRun, SnakeViz</li>
                        </ul>
                        <aside class="notes">
                            First rule of optimization: Don't. Ok, that was easy. Thank you for your attention.<br>
                            Well, actually now, there is more.<br>
                            So what does it mean 'Don't.<br>
                            Well, 9 out of 10 times when you think you need optimization, you don't, especially in the early stage of your product's life.<br>
                            You might think it would be nice to optimize your code a bit, but first of all, you will waste time doing something that is not needed. You can get more benefits from getting a faster hardware of something if you want. Second of all, optimization comes with a cost. Sometimes it's only the time spend optimizing existing code. Sometimes you have to add even more time to fix, what you broke with you optimization. But also, the optimized code might not be as readable as it was in the first place. And maybe your code is running faster but uses more memory ? So unless you have real resons to optimize - don't do this.
                            If you know that you really need to optimize, then you can move to the second rule of optimization - don't do this yet. This is how I understand it:<br>
                            First make sure your code works<br>
                            Then make sure you have good test suite<br>
                            And only then, you are ready for optimization.<br>
                            I love this rule, it always reminds me how many times I have violated it. So many times I was in the middle of working on a more or less complex piece of code and then I started thinking: "Hmm, I can change that piece of code and probably it will be faster - also I will save 2 lines of code".<br>
                            Was it a good idea ?<br>
                            Nope. And not only because I ended up breaking things. Well, quite often I did end up breaking things, but also, when I started jumping around the code, I forgot what exactly was I writing in the first place.<br>
                            One way or another, it was causing confusion and additional work.<br>
                            Did it make my code faster ?<br>
                            I have no idea, because I had nothing to compare it to! If I had written the whole function first and then improve it, I could measure it and see if it's better or worse now, but otherwise I could only guess.<br>
                            And that brings me to the last rules of optimization - Don't guess.<br>
                            Always profile your code before optimization. Human are terrible in predicting bottlenecks of the code. If you code is slow - profile it and see what takes the most time. Otherwise, you might end up spending time to rewrite part of your code just to make it 1% faster, while there are other parts of the system where you can gain much more improvements with less effort.
                            There are plenty of profiling tools, if you don't know where to start, you can try the built-in Python profiler called cProfile.<br>
                            It will show you a clear overview of how many times each function is called and where is your code spending most of the time, so there is no need to guess.<br>
                            You can combine it with the pstats module, which allows for more advanced formatting of the results.<br>
                            If you prefer a graphical interface, there are also libraries like that. RunSnakeRun and SnakeViz seems to be the most common.
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Levels of optimization</h3>
                        <ul>
                            <li class="fragment">Design</li>
                            <li class="fragment">Algorithms and data structures</li>
                        </ul>
                        <aside class="notes">
                            Once we are ready for optimization, we have to decide, on which area we want to focus.<br>
                            There are different levels of optimization:<br>
                            Starting from the highest level, you have the design level optimization. Depending on the constrains and priorities of your system, you can optimize it by redesigning it. It might require rewriting parts or the whole application in a different programming language that might be faster, changing the type of a database or redesigning the architecture of your software to limit the number of DB queries etc.<br>
                            We are probably not interested in this kind of optimization today, as we are not going to rewrite something that we have been working very hard on in the past months or years. However, if you have some critical parts of the code that are run often, you can optimize it by rewriting it in C or C++. Because C is faster, you can get some good speed improvement for free. Well, not really for free - now you have to maintain Python AND C/C++ code in one project.

                            One level lower, we have algorithms and data structures. That's usually the second biggest improvement you can get after a complete redesign. Knowing different algorithms together with their complexity definitely helps creating good, fast software.
                        </aside>
                    </section>
                    <section>
                        <pre><code class='python' data-trim data-noescape>
sum = 0
for x in range(1, N + 1):
    sum += x
print sum
                        </code></pre>
                        <div class="fragment">
                            <p class="arrow">&#8595;</p>
                            <pre><code class='python' data-trim data-noescape>
print N * (1 + N) / 2
                            </code></pre>
                        </div>
                        <aside class="notes">
                            For example, you want to get a sum of numbers from 1 to N. The first idea might be a loop that goes though all elements and adds them.<br>
                            It will work, but it won't be fast.<br>
                            You can instead use an algorithm for the arithmetic sum, which will give you the same results and it will be more efficient.
                        </aside>
                    </section>
                    <section>
                        <h3>Levels of optimization</h3>
                        <ul>
                            <li>Design</li>
                            <li>Algorithms and data structures</li>
                            <li>Source code</li>
                            <li class="fragment">Build level</li>
                            <li class="fragment">Compile level</li>
                            <li class="fragment">Assembly level</li>
                            <li class="fragment">Runtime level</li>
                        </ul>
                        <aside class="notes">
                            Next level is the source code optimization. This is something that I want to talk about today. We are slowly getting there.

                            And now we got to the low levels of optimization. For example, "build level" involves setting up specific build flags. In you daily work, it's not something that you do often. You can optimize Python for a specific architecture, but if you are a web-developer like me, you don't go to that level of optimization.

                            Compile level - you can make some optimizations if you are using Ahead of Time compiler. Which is not the case for Python, as there is no ahead of time compiler for Python.

                            Assembly level - this is probably as low as you can get with the optimization. For additional performance, you can write directly the assembly code for a specific architecture. As this is "Python Developers Forum", not the "Assembly Developers Forum", I will not focus on this level of optimization either.

                            Last but not least - runtime level. It's related with a specific compiler you are using. Some compilers are faster than the others, for example if you replace CPython with PyPy, you can gain on average up to 7 times speed improvement, but again, it depends on what kind of task you are doing.<br>
                            Most of the time, once we set up on a specific language implementation, there is nothing we have to do to benefit from this kind of optimizations - it's up to the creators of the compilers to optimize them, so simply updating to the new version of the programming language you are using can make your programs run a bit faster.
                        </aside>
                    </section>
                </section>
                <!-- Optimization is not only the speed -->
                <section>
                    <section>
                        <h4>Optimization is all about the speed</h4>
                        <div class="fragment">
                            <h4>... and memory</h4>
                        </div>
                        <div class="fragment">
                            <h4>... and disk space</h4>
                            <h4>... disk I/O</h4>
                            <h4>... network I/O</h4>
                            <h4>... power consumption</h4>
                            <h4>... and more.</h4>
                        </div>
                        <aside class="notes">
                            So, when you optimize you probably want your code to run faster.<br>
                            And also use less memory. And less disk space, perform less disk I/O, network I/O, less power consumption, etc. etc.
                            The bad news is - you can't have all of this. Optimization in one area will usuallycause deterioration in other areas.
                            So you have to always decide, which resources are crucial to you and try to optimize in that direction.
                            So it's possible that optimization will have nothing to do with the execution time at all, as there can be other resources more important than the raw speed.
                            For example, who cares if you program is now 10 times faster if it's crashing half of the time, because it's running out of memory ?
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <div class="blockquote">
                            <blockquote>
                                <p>Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live</p>
                            </blockquote>
                            <div class="blockquote-attribution">
                                <p class="blockquote-author">
                                    John Woods
                                </p>
                            </div>
                        </div>
                        <aside class="notes">
                            Another important resource of optimization that people are often forgetting is sanity.<br>
                            Sanity of a person, who will be maintaining your code. So please, be nice to that person, you never know who that might be.<br>
                            Unless you are really writing a throw-away code, if you are making the code harder to read and maintain, then you are probably doing it wrong!
                        </aside>
                    </section>
                </section>
                <!-- SOURCE CODE OPTIMIZATION -->
                <section>
                    <section>
                        <h2>Writing fast Python</h2>
                        <h5>a.k.a source code optimization</h5>
                        <aside class="notes">
                            Having those things cleared, let's jump straight to how you can write faster Python, also known as source code optimization.<br>
                        </aside>
                    </section>
                    <section>
                        <h3 class="mb50">Setup</h3>
                        <p class="mb50">Python 3.5.1 (IPython 1.2.1)</p>
                        <pre><code class='python' data-trim data-noescape>
def ultimate_answer_to_life():
    return 42
                        </code></pre>
                        <p>&nbsp;</p>
                        <pre><code class='python' data-trim data-noescape>
>>> %timeit ultimate_answer_to_life()
10000000 loops, best of 3: 87.1 ns per loop
                        </code></pre>
                        <p>&nbsp;</p>
                        <p class="source-link">
                            2.72 × 10<sup>21</sup> times faster than in <a href="https://en.wikipedia.org/wiki/42_(number)#Hitchhiker.27s_Guide_to_the_Galaxy">The Hitchhiker's Guide to the Galaxy</a> ;-)
                        </p>
                        <aside class="notes">
                            In my examples I'm using version 3.5.1 of Python together with IPython, although unless I point it out, all the examples should apply to both Python 2 and 3.<br>
                            For measuring execution times of code, I will use the magic %timeit function. It has some overhead comparing with the standard timeit library, but it doesn't really matter - as long as we use the same method to measure execution time of different functions, we only need to know which method is faster and by how much.<br>
                            So for each of my example, I write different versions of code, measure the execution time and compare them.
                        </aside>
                    </section>
                </section>

                <!-- List of examples: -->
                <!-- built-ins Counting elements in a list vs using a built-in-->
                <!-- list Filter a list -->
                <!-- dict List with index -->

                <!-- Ask for permissions vs beg for forgiveness -->


                <!-- string/list Create a string from a list -->
                <!-- string String formatting is faster than string concatenation -->

                <!-- functions Execute operation 1000 times in a function than a function 1000 times -->
                <!-- list List sorting is faster in place -->
                <!-- bool Checking for True -->
                <!-- bool Checking for False -->
                <!-- list Checking if list in empty -->
                <!-- function Lambda vs def -->
                <!-- function [] vs list() and {} vs dict() -->

                <!-- DANGER ZONE -->
                <!-- Parallel vs sequential variables assignment -->
                <!-- Local vs global/built-in variables -->



                <!-- Counting elements in a list -->
                <section>
                    <section>
                    <h4 class="mb50"><span class="orange">#1</span> Count elements in a list</h4>
                        <pre><code class='python' data-trim data-noescape>
how_many = 0
for element in ONE_MILLION_ELEMENTS:
    how_many += 1
print how_many
                        </code></pre>
                        <p>
                            <span class="bad">26.5 ms</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
print len(ONE_MILLION_ELEMENTS)
                        </code></pre>
                        <p>
                            <span class="good">96.7 ns</span>
                        </p>
                        <p>
                            <span class="good">274 000</span> times faster
                        </p>
                        <aside class="notes">
                            Let's start with something simple. Let's say you want to count the number of elements in a list.<br>
                            You can easily write a simple loop that increments a counter and, while this will work, it will be very slow.<br>
                            You can achieve the same results by simply calling the built-in function len().<br>
                            And as you can see even for only 1 million elements, the speed difference is insanely huge.<br>
                            So, my first advice is to not reinvent the wheel, but first check if there is a function that you can use.
                        </aside>
                    </section>
                    <section data-background="#f7f3de">
                        <img src="./img/built-ins.png">
                        <small class="source-link">And <a href="https://docs.python.org/3/library/collections.html">collections</a> module.</small>
                        <aside class="notes">
                            Python 3.5.1 has 68 built-in functions, so it's good to take a look at them from time to time and keep them in the back of your head, because they might be handy at some point.<br>
                            Also, before you start writing your own version of ordered dictionary or dictionary with default values, take a look at the collections module from the standard library.<br>
                            Even though it contains only like 10 different datatypes, they are probably THE datatypes you are looking for when the standard ones are not enough.
                        </aside>
                    </section>
                </section>


                <!-- Filter a list -->
                <section>
                <h4 class="mb50"><span class="orange">#2</span> Filter a list</h4>
                    <pre><code class='python' data-trim data-noescape>
output = []
for element in MILLION_NUMBERS:
    if element % 2:
        output.append(element)
                    </code></pre>
                    <p>
                        <span class="bad">222 ms</span>
                    </p>
                    <div class='fragment'>
                        <pre><code class='python' data-trim data-noescape>
list(filter(lambda x: x % 2, MILLION_NUMBERS))
                        </code></pre>
                        <p>
                            <span class="bad">234 ms</span>
                        </p>
                    </div>
                    <div class='fragment'>
                        <pre><code class='python' data-trim data-noescape>
[item for item in MILLION_NUMBERS if item % 2]
                        </code></pre>
                        <p>
                            <span class="good">127 ms</span><br>
                            75% faster
                        </p>
                    </div>
                    <aside class="notes">
                        Let's say you have a list of 1 million numbers and you want to select only the odd numbers.<br>
                        The naive version would be to use a for loop, so for each element of the list you check if it's odd and if it is, the you add it to another list.<br>
                        But I already showed you in the previous example that in most cases, for loops can be replaced with something better.<br>
                        In this case, you could use the built-in filter function instead.<br>
                        In Python 2, filter was returning a list directly.<br>
                        In Python 3, it's returning an iterator, so I need to call list function on that iterator to get the same results as in case of the loop.<br>
                        Even though calling list function has some impacts on the performance, it's negligible comparing to the time spent in filter function.<br>
                        And as we can see, filter performs even slower than the for loop.<br>
                        Why does this happen ?<br>
                        Well, the fact that filter is now returning an iterator is a clear suggestion that this is a wrong use case for filter function.<br>
                        If we want to get the whole list as a result, the better idea is to use list comprehension.<br>
                        It's around 75% faster than the for loop and - at least for me - it looks very clear.
                    </aside>
                </section>


                <!-- List with index -->
                <section>
                    <h4 class="mb50"><span class="orange">#2.5</span> List with index</h4>
                    <pre><code class='python' data-trim data-noescape>
output = {}
for i in range(0, len(MILLION)):
    output[i] = MILLION[i]
                    </code></pre>
                    <p>
                        <span class="bad">334 ms</span><br>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
output = {}
for i, element in enumerate(MILLION):
    output[i] = element
                    </code></pre>
                    <p>
                        <span class="good">220 ms</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
{i: element for i, element in enumerate(MILLION)}
                    </code></pre>
                    <p>
                        <span class="good">218 ms</span><br>
                        50% faster
                    </p>
                    <aside class="notes">
                        Ok, so for loops can often be avoided.<br>
                        But what if you need to iterate over a list and also get the index.<br>
                        Let's say, you want to take a list and convert it to a dictionary, in such way that index of each element becomes a key of that dictionary, and the value in list becomes the value in the dictionary.<br>
                        There is a bad was to do this, where you basically iterate over numbers from 0 to 1 million and take the value corresponding to that number in the list.<br>
                        That's a bad idea, because you can use the enumerate function to get the index.<br>
                        And it's going to be faster by 50%.<br>
                        But it's still a for loop with only one instruction inside, so it can easily be replaced with dictionary comprehension.<br>
                        The speed performance of dictionary comprehension is the same as using the enumerate, but again it's shorter and more clear.
                    </aside>
                </section>

                <!-- Ask for permissions vs beg for forgiveness -->
                <section>
                    <section>
                        <h4 class="mb50"><span class="orange">#3</span> Permissions or forgiveness ?</h4>
                        <pre><code class='python' data-trim data-noescape>
class Foo(object):
    hello = 'world'
foo = Foo()
                        </code></pre>
                        <pre><code class='python' data-trim data-noescape>
if hasattr(foo, 'hello'):
    foo.hello
                        </code></pre>
                        <p>
                            <span class="bad">149 ns</span><br>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
try:
    foo.hello
except AttributeError:
    pass
                        </code></pre>
                        <p>
                            <span class="good">43.1 ns</span><br>
                            3.5 times faster
                        </p>
                        <aside class="notes">
                            When you want to execute a piece of code, but you are not sure it will be successful (maybe some variables are not set or like here, the class doesn't have a specific attribute), so you want to protect yourself somehow. The first way you can do this is called 'Look before you leap' or 'Ask for permission'. What is means is that you fist check if the class has a specific attribute and then you perform the operations. Usually this checking is done with the if statement.
                            However, there is a different approach that you could use - it's called "Beg for forgiveness". In this scenario, you perform your operations without checking the conditions, but in case you expect that something might break, you wrap you code in a try/except block and catch the exceptions that were raised.
                            As you can see in this simple example, begging for forgiveness is 3 times faster.
                        </aside>
                    </section>
                    <section>
                    <h4 class="mb50"><span class="orange">#3</span> Permissions or forgiveness ?</h4>
                        <pre><code class='python' data-trim data-noescape>
if (hasattr(foo, 'foo') and hasattr(foo, 'bar')
    and hasattr(foo, 'baz')):
    foo.foo
    foo.bar
    foo.baz
                        </code></pre>
                        <p>
                            <span class="bad">401 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
try:
    foo.foo
    foo.bar
    foo.baz
except AttributeError:
    pass
                        </code></pre>
                        <p>
                            <span class="good">110 ns</span><br>
                            3.64 times faster
                        </p>
                        <aside class="notes">
                            But it gets even better if you are checking for more conditions.<br>
                            Here, we are checking if 3 attributes are available.<br>
                            Asking for permissions is still slower and now it also gets more difficult to read.<br>
                            Following the beg for forgiveness approach will result in faster and more readable code.<br>
                            So, we could say that asking for forgiveness instead of checking the permissions as always a better choice.
                        </aside>
                    </section>
                    <!-- Ask for permissions vs beg for forgiveness 3 -->
                    <section>
                    <h4 class="mb50"><span class="orange">#3</span> Permissions or forgiveness ?</h4>
                        <pre><code class='python' data-trim data-noescape>
class Bar(object):
    pass
bar = Bar()
                        </code></pre>
                        <pre><code class='python' data-trim data-noescape>
if hasattr(bar, 'hello'):
    bar.hello
                        </code></pre>
                        <p>
                            <span class="good">428 ns</span><br>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
try:
    bar.hello
except AttributeError:
    pass
                        </code></pre>
                        <p>
                            <span class="bad">536 ns</span><br>
                            25% slower
                        </p>
                        <aside class="notes">
                            But we won't say that, because it's not true.<br>
                            Exceptions handling is still quite expensive.<br>
                            If the object doesn't have the attribute we are looking for, begging for forgiveness will be slower than asking for permissions.<br>
                            So as a rule of thumb, you can use the 'Ask for permissions' way if you know that it's very likely that the attribute will be missing or there will be some other problems that you can predict.<br>
                            Otherwise, if you are expecting that your code will work fine for most of the time, using try/except will be faster and quite often more readable way to go<br>
                            For example, you are fetching some files from the internet and you are expecting that it will work, unless there is no internet connection, then instead of checking if there is network connection, if it's fast enough, no timeouts, etc. just go for try/except.<br>
                            But again, I strongly advise you to measure both solutions to see which one is faster in your scenario.
                        </aside>
                    </section>
                </section>




                <!-- Check list membership -->
                <section>
                    <section>
                        <h4 class="mb50"><span class="orange">#4</span> Membership testing</h4>
                        <pre><code class='python' data-trim data-noescape>
def check_number(number):
    for item in MILLION_NUMBERS:
        if item == number:
            return True
    return False
                        </code></pre>
                        <pre><code class='python' data-trim data-noescape>
%timeit check_number(500000)
                        </code></pre>
                        <p>
                            <span class="bad">21.4 ms</span>
                        </p>
                        <aside class="notes">
                            Let's tackle another problem - membership testing.<br>
                            If you have a list and want to check if it contains a specific element, you can use for loop.<br>
                        </aside>
                    </section>
                    <section>
                        <h4 class="mb50"><span class="orange">#4</span> Membership testing</h4>
                        <pre><code class='python' data-trim data-noescape>
def check_number(number):
    if number in MILLION_NUMBERS:
        return True
    return False
                        </code></pre>
                        <pre><code class='python' data-trim data-noescape>
%timeit check_number(500000)
                        </code></pre>
                        <p>
                            <span class="good">11.9 ms</span><br>
                            80% faster
                        </p>
                        <aside class="notes">
                            But the problem is, you are iterating over the list, event though you are not really doing anything with all the elements.<br>
                            You can replace the for loop with the in statement.<br>
                            It will check if specific element belongs to given set of data.<br>
                            And it will do this around 80% faster.<br>
                            Ok, but there is still one big problem with this approach.<br>
                        </aside>
                    </section>
                    <section>
                        <h4 class="mb50"><span class="orange">#4</span> Membership testing</h4>
                        <pre><code class='python' data-trim data-noescape>
%timeit check_number(100)
                        </code></pre>
                        <p>
                            <span class="bad">1.55 µs</span><br>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
%timeit check_number(999999)
                        </code></pre>
                        <p>
                            <span class="bad">22.9 ms</span>
                        </p>
                        <aside class="notes">
                            The lookup time in a list is linear.<br>
                            So, if an element is at the beginning of the list, you are lucky and you get it fast.<br>
                            If it's at the end, well, then you wait a bit more.<br>
                            You know what would be great here ?<br>
                            If we could have a data structure with faster lookup time.<br>
                            And we have - both a set and a dictionary have constant lookup time.<br>
                        </aside>
                    </section>
                    <section>
                        <h4 class="mb50"><span class="orange">#4</span> Membership testing</h4>
                        <pre><code class='python' data-trim data-noescape>
MILLION_SET = set(MILLION_NUMBERS)
%timeit 100 in MILLION_SET
                        </code></pre>
                        <p>
                            <span class="good">46.3 ns</span><br>
                            33 times faster (vs list)
                        </p>
                        <pre><code class='python' data-trim data-noescape>
%timeit 999999 in MILLION_SET
                        </code></pre>
                        <p>
                            <span class="good">63.3 ns</span><br>
                            360 000 times faster (vs list)
                        </p>
                        <div class="fragment">
                            <pre><code class='python' data-trim data-noescape>
%timeit set(MILLION_NUMBERS)
                            </code></pre>
                            <p>
                                <span class="good">106 ms</span>
                            </p>
                        </div>
                        <aside class="notes">
                            If we replace the list with a set, the lookup time becomes faster.<br>
                            From few times faster to hundreds of thousands times faster.<br>
                            Where is the catch ?<br>
                            Well, you pay some time for converting list to a set.<br>
                            In this example, converting list to a set is slower than any of the lookups in the list, so it doesn't make sense to do this.<br>
                            However, if you are testing membership of more than 1 element, very often it makes sense to convert the list to a set.
                        </aside>
                    </section>
                </section>




                <!-- List sorting is faster in place -->
                <section>
                    <h4 class="mb50"><span class="orange">#4</span> List sorting</h4>
                    <pre><code class='python' data-trim data-noescape>
sorted(MILLION_RANDOM_NUMBERS)
                    </code></pre>
                    <p>
                        <span class="bad">467 ms</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
MILLION_RANDOM_NUMBERS.sort()
                    </code></pre>
                    <p>
                        <span class="good">77.6 ms</span><br>
                        6 times faster
                    </p>
                    <aside class="notes">
                        If you want to sort a list, you can either do this in place with list.sort function or call the sorted function, that will create a new list.<br>
                        Unless you really need to have a new list, sorting in place will be faster<br>
                        For 1 million random numbers, sorting in place is 6 times faster than creating a new list.
                    </aside>
                </section>




                <!-- List to string -->
<!--                 <section class="example">
                <h4><span class="orange counter"></span> List to string</h4>
                    <pre><code class='python' data-trim data-noescape>
# Create a list of 1000 words:
LIST = ['word'] * 1000
                    </code></pre>
                    <pre><code class='python' data-trim data-noescape>
result = ''
for word in LIST:
    result += word
                    </code></pre>
                    <p>vs</p>
                    <pre><code class='python' data-trim data-noescape>
result = ''.join(LIST)
                    </code></pre>
                    <p>
                        10000 loops, best of 3: 94 µs per loop
                        100000 loops, best of 3: 8.54 µs per loop

                        <span class="bad">94 µs</span> vs <span class="good">8.54 µs</span><br>
                        11 times faster
                    </p>
                    <aside class="notes">
                        Let's talk about string for now. If you have a list of strings and want to concatenate them into one string, using a loop is not the best idea. Instead, you can use the join function, that will be much faster (and clearer to understand). Here, for a list of 1000 words, the join function is 11 times faster. I have also tested it with longer words and even though the difference got lower (for 1000 words of 600 characters, join was 'only' twice as fast), join function is still a clear winner here.
                    </aside>
                </section> -->




                <!-- String formatting is faster than string concatenation -->
<!--                 <section>
                <h4><span class="orange">#</span> String formatting or string concatenation ?</h4>
                <h2>This is not working, find better example: https://wiki.python.org/moin/PythonSpeed/PerformanceTips#String_Concatenation</h2>
                    <pre><code class='python' data-trim data-noescape>
word1 = 'Hello'
word2 = 'world'
word3 = 'from'
word4 = 'EuroPython'
                    </code></pre>
                    <pre><code class='python' data-trim data-noescape>
"This is:" + word1 + word2 + word3 + word4 + "!"
                    </code></pre>
                    <pre><code class='python' data-trim data-noescape>
"This is:%s%s%s%s!" % (word1, word2, word3, word4)

                    </code></pre>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                    1000000 loops, best of 3: 369 ns per loop

                        In case you are trying to concatenate just a few strings, not a whole list, you are also better of with using string formatting, instead of concatenation operator.
                    </aside>
                </section>
 -->





                <!-- Execute operation 1000 times in a function than a function 1000 times -->
                <section>
                    <h4 class="mb50"><span class="orange">#5</span> 1000 operations and 1 function</h4>
                    <pre><code class='python' data-trim data-noescape>
def square(number):
    return number**2
squares = [square(i) for i in range(1000)]
                    </code></pre>
                    <p>
                        <span class="bad">399 µs</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
def compute_squares():
    return [i**2 for i in range(1000)]
                    </code></pre>
                    <p>
                        <span class="good">314 µs</span><br>
                         27% faster
                    </p>
                    <aside class="notes">
                        If you want to perform the same operation on a large set of data, you have two options.<br>
                        You can write a function that performs the operation and then call this function 1000 time.<br>
                        Or, you can write a function that takes those 1000 elements and performs the operation inside.<br>
                        And the second approach will be faster, so if you can easily change your code, especially if you have a simple function, and replace multiple calls to a function with one function, then probably it's a good idea.
                    </aside>
                </section>




                <!-- Checking for True -->
                <section>
                    <section>
                        <h4 class="mb50"><span class="orange">#</span> Checking for True</h4>
                        <pre><code class='python' data-trim data-noescape>
if variable == True:
                        </code></pre>
                        <p>
                            <span class="bad">35.8 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if variable is True:
                        </code></pre>
                        <p>
                            <span class="bad">28.7 ns</span><br>
                            24% faster
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if variable:
                        </code></pre>
                        <p>
                            <span class="good">20.6 ns</span><br>
                            73% faster
                        </p>
                        <aside class="notes">
                            What is the best way to check if a variable or expression is True ?<br>
                            You can explicitly compare this variable to True, but unless you really want to check if a variable is True (and not for example 0 or None), then using the first two versions is adding unnecessary redundancy.<br>
                            You can simplify your condition to just 'if variable'. It will return True, unless the variable is False, None, 0, empty string, empty list or any other "Falsy" expression.<br>
                            And by doing that, your comparison gets almost twice faster.
                        </aside>
                    </section>
                    <!-- Checking for False -->
                    <section>
                        <h4 class="mb50"><span class="orange">#</span> Checking for False</h4>
                        <pre><code class='python' data-trim data-noescape>
if variable == False:
                        </code></pre>
                        <p>
                            <span class="bad">35.1 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if variable is False:
                        </code></pre>
                        <p>
                            <span class="bad">26.9 ns</span><br>
                            30% faster
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if not variable:
                        </code></pre>
                        <p>
                            <span class="good">19.8 ns</span><br>
                            77% faster
                        </p>
                        <aside class="notes">
                            The same rule applies when checking for False.<br>
                            The fastest way to do this is to use 'if not variable', unless you really need to distinguish False from None, 0 or other Falsy values.
                        </aside>
                    </section>
                    <!-- Checking for empty list -->
                    <section>
                        <h4 class="mb50"><span class="orange">#</span> Checking for empty list</h4>
                        <pre><code class='python' data-trim data-noescape>
if len(a_list) == 0:
                        </code></pre>
                        <p>
                            <span class="bad">91.7 ns</span>
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if a_list == []:
                        </code></pre>
                        <p>
                            <span class="bad">56.3 ns</span><br>
                            60% faster
                        </p>
                        <pre><code class='python' data-trim data-noescape>
if not a_list:
                        </code></pre>
                        <p>
                            <span class="good">32.4 ns</span><br>
                            280% faster
                        </p>
                        <aside class="notes">
                            Two slides before I said that the if not statement is checking for Falsy expressions and Falsy means: False, but also 0, None, empty list, empty string, empty set, dictionary or other data structure.<br>
                            You can take advantage of that for checking, for example  if a list is empty.<br>
                            Simply doing "if not a_list", will be almost 3 times faster than explicitelly checking for the length of a list.
                        </aside>
                    </section>
                </section>

                <!-- Lambda vs def -->
                <section>
                <h4><span class="orange">#</span> Lambda vs def</h4>
                    <p>Def:</p>
                    <pre><code class='python' data-trim data-noescape>
def greet_def(name):
    return 'Hello {}!'.format(name)
                    </code></pre>
                    <p>Lambda:</p>
                    <pre><code class='python' data-trim data-noescape>
greet_l = lambda name: 'Hello {}!'.format(name)
                    </code></pre>
                    <p>Compare:</p>
                    <pre><code class='python' data-trim data-noescape>
>>> %timeit greet_def('Tom')
1000000 loops, best of 3: 329 ns per loop
>>> %timeit greet_l('Tom')
1000000 loops, best of 3: 332 ns per loop
                    </code></pre>
                    <aside class="notes">
                        Let's take a look at different ways of defining functions in Python. The most common way to create a function is with def keyword. The other way is to declare an anonymous function with lambda. If you assign this lambda to a variable it will act in the same way as function created with def keyword.
                        So let's see which version is faster.
                        Well, actually they are both equally fast.
                        Why ? Because both version exactly the same thing.
                        We can see that even better when disassembling the code of both function.
                    </aside>
                </section>
                <!-- Lambda vs def contd.-->
                <section>
                <h4><span class="orange">#</span> Lambda vs def</h4>
                    <pre><code class='python' data-trim data-noescape>
>>> dis.dis(greet_def)
 0 LOAD_CONST    1 ('Hello {}!')
 3 LOAD_ATTR     0 (format)
 6 LOAD_FAST     0 (name)
 9 CALL_FUNCTION 1 (1 positional, 0 keyword pair)
12 RETURN_VALUE
                    </code></pre>
                    <pre><code class='python' data-trim data-noescape>
>>> dis.dis(greet_l)
 0 LOAD_CONST    1 ('Hello {}!')
 3 LOAD_ATTR     0 (format)
 6 LOAD_FAST     0 (name)
 9 CALL_FUNCTION 1 (1 positional, 0 keyword pair)
12 RETURN_VALUE
                    </code></pre>
                    <small><a href='http://stackoverflow.com/questions/29804774/why-is-lambda-expression-necessary-in-this-example-python'>Stack Overflow on when lambda might be necessary</a></small>
                    <aside class="notes">
                        So is there any difference ?
                        Well, if your function has more than one line, then you can't use lambda.
                        Also, you can't really put documentation inside lambda function.
                        And if you have PEP-8 enabled in you code editor, it will complain each time you try to assign lambda to a variable.
                        And he is right, lambda works really nice when you need a simple one-liner callback for functions, especially for functions like filter, map or reduce.
                        There are also some quite narrow use cases when it might be necessary to use the lambda instead of def as a callback - if you want to read more, I'm linking a stack overflow question with that problem.
                        However, for any other case, I would use def. It's much cleaner, you can document it properly and the performance is the same.
                    </aside>
                </section>
                <!-- [] vs list() and {} vs dict() -->
                <section>
                <h4><span class="orange"></span>[] and {}</h4>
                    <div>
                        <div class='left'>
                            <pre><code class='python' data-trim data-noescape>
list()
                            </code></pre>
                            <p>
                                <span class="bad">104 ns</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>
[]
                            </code></pre>
                            <p>
                                <span class="good">22.5 ns</span>
                            </p>
                            <p>
                                4.6 times faster
                            </p>
                        </div>
                        <div class='right'>
                            <pre><code class='python' data-trim data-noescape>
dict()
                            </code></pre>
                            <p>
                                <span class="bad">161 ns</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>
{}
                            </code></pre>
                            <p>
                                <span class="good">93 ns</span>
                            </p>
                            <p>
                                1.7 times faster
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        There are 2 ways you can create an empty list or a dictionary. You can either call a function for that, or you can simply use the literal syntax.
                        As you can see, using the literal syntax is way faster.
                        Let's take a quick look, why this happens.
                    </aside>
                </section>
                <!-- DANGER ZONE - although those examples are faster, I don't recommend them as they make your code less readable !!!
                     Treat those examples as curiosities -->
                <!-- Parallel vs sequential variables assignment -->
                <section>
                <h4><span class="orange">#</span>Variables assignment</h4>
                    <pre><code class='python' data-trim data-noescape>
q=1
w=2
e=3
r=4
t=5
y=6
u=7
i=8
o=9
p=0

                    </code></pre>
                    <p>
                        <span class="bad">71.8 ns</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
q,w,e,r,t,y,u,i,o,p = 1,2,3,4,5,6,7,8,9,0
                    </code></pre>
                    <p>
                        <span class="good">56.4 ns</span><br>
                        27% faster (but please don't)
                    </p>
                    <aside class="notes">
                        One interesting thing is variables assignments.<br>
                        If you have a bunch of variables that you need to assign, you can either do this the normal, sequential way or you can pull this crazy parallel assignment.<br>
                        Indeed, you can gain some speed, but you can easily gain hate from someone reading your code later.<br>
                        In my opinion, it's not worth it.
                    </aside>
                </section>
                <!-- Local vs global/built-in variables  -->
                <section>
                <h4><span class="orange">#</span> Variables lookup</h4>
                    <pre><code class='python' data-trim data-noescape>
def squares(MILLION_NUMBERS):
    output = []
    for element in MILLION_NUMBERS:
        output.append(element*element)
    return output
                    </code></pre>
                    <p>
                        <span class="bad">149 ms</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
def squares_faster(MILLION_NUMBERS):
    output = []
    append = output.append # <= !!!!!!!!
    for element in MILLION_NUMBERS:
        append(element*element)
    return output
                    </code></pre>
                    <p>
                        <span class="good">110 ms</span><br>
                        35% faster (and 27% less clear)
                    </p>
                    <aside class="notes">
                        Another interesting property of Python - local variable lookup is faster than global or built-in lookup.<br>
                        So you can save some time if, for example, you store the reference to a built-in function in a local variable.<br>
                        In this example, the only difference is that I store the reference to append function of a list in a variable called append.<br>
                        Thanks to that, this function is 35% faster, but then again, if you see this code for the first time, it's not obvious what it is supposed to do.<br>
                        It might be confusing to see this append function inside that for loop, as we are used to see the list.append version more often.
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </code></pre>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </code></pre>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </code></pre>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </code></pre>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </code></pre>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </code></pre>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- SPLIT DIV -->
                <section>
                <h4><span class="orange">#</span> SPLIT DIV </h4>
                    <div>
                        <div class='left'>
                            <pre><code class='python' data-trim data-noescape>

                            </code></pre>
                            <p>
                                <span class="bad">xxxxxx</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>

                            </code></pre>
                            <p>
                                <span class="good">xxxxxx</span>
                            </p>
                            <p>
                                xxxxxxxxx
                            </p>
                        </div>
                        <div class='right'>
                            <pre><code class='python' data-trim data-noescape>

                            </code></pre>
                            <p>
                                <span class="bad">xxxxxxxx</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>

                            </code></pre>
                            <p>
                                <span class="good">xxxxxxxx</span>
                            </p>
                            <p>
                                xxxxxxxxxx
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,
                slideNumber: 'c/t',

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
