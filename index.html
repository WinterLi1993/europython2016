<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Writing fast Python</title>
        <meta name="description" content="Presentation about source code level optimizations for Python">
        <meta name="author" content="Sebastian Witowski">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">

        <!-- Reveal.js theme -->
        <link rel="stylesheet" href="css/theme/blood.css">
        <!-- Custom CSS rules -->
        <link rel="stylesheet" href="css/custom.css">
        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/gruvbox-dark.css">
        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <!-- Vertical slides for different title variations -->
                    <section>
                        <h1>Writing faster code</h1>
                        <aside class="notes">
                            Hi everyone.<br>
                            I would like to talk with you about writing faster code. Last time I gave a short talk on how to make your Python code faster, I remember someone pointing out that 'basically you can rewrite your code in C to make it faster'.<br>
                            And you know what ? The guy was absolutely right. Take any piece of code, rewrite it in C or C++ and it will be automatically faster.<br>
                            So I was thinking, "Hmm, if I say just 'writing faster code', people will be confused if it's only about Python or not".<br>
                            So I decided to fix it.<br>
                        </aside>
                    </section>
                    <section>
                        <h2>Writing faster code <span class='orange'>and not hating your job as a software developer</span></h2>
                        <aside class="notes">
                            I was very happy with the new title. It makes it clear that we are not talking about Java or C here.<br>
                            But then I remembered from school that the presentation title should be clear but also concise.
                            And frankly - this one barely even fits on the slides.<br>
                            So I had to fix it again.<br>
                        </aside>
                    </section>
                    <section>
                        <h1>Writing faster <span class='orange'>Python</span></h1>
                        <aside class="notes">
                            And this is how I ended up with 'Writing faster Python' as a title for my today's talk.
                            Let's put aside the flame war about which programming language is better.<br>
                            (Whisper) We all know the answer, that's why you are here!(/Whisper)
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h4>Python was not made to be fast...</h4>
                        <h4>...but to make programmers happy.</h4>
                        <aside class="notes">
                            Python was not created to be a fast language that you would use for some LHC computations where every nanosecond counts.<br>
                            And that's fine with me. Python is a great programming language that is easy and fun to use.<br>
                        </aside>
                    </section>
                    <section>
                        <!-- TODO: MAKE quotes pretty: http://tympanus.net/Tutorials/ModernBlockQuoteStyles/index3.html -->
                        <blockquote>
                            <p>It was nice to learn Python; a nice afternoon</p>
                            <footer>Donald Knuth</footer>
                        </blockquote>
                        <aside class="notes">
                            Python is very easy to learn. The ease of use and read is very encouraging for people new to development.<br>
                            I see that it's getting more and more popular in schools or universities as the first programming language that people are learning.<br>
                        </aside>
                    </section>
                    <section>
                        <pre><code class='python' data-trim data-noescape>
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
                        </code></pre>
                        <p>vs.</p>
                        <pre><code class='python' data-trim data-noescape>
print("Hello, world!")
                        </code></pre>
                        <aside class="notes">
                            And I'm not surprised. I mean, imagine you are completely new to programming and someone tells you: "Hey, let me show you how much fun is programming. Let's start with something simple and print some text to the screen."<br>
                            And then he shows you one of those examples.<br>
                            One of them is clearly not something that you would show to a beginner to encourage him to start programming.
                        </aside>
                    </section>
                    <section>
                        <p>TODO: Get statistics for python usage</p>
                        <small>http://expandedramblings.com/index.php/dropbox-statistics/ and https://www.dropbox.com/about</small>
                        <aside class="notes">
                            So let's take a look at how slow Python is.
                            There quite a lot of big websites and services out there that are using Python as their back-end.
                            https://www.shoop.io/en/blog/25-of-the-most-popular-python-and-django-websites/

                            You guys probably heard about Instagram. You can post pictures of your food there. And cats.
                            So Instagram is using Python in their backend. They have over 400 millions active users monthly, who post more than 80 millions pictures daily and they don't seem to complain about Python.
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h1 class='h1-smaller'>OPTIMIZATION</h1>
                        <aside class="notes">
                            So Python is usually fast enough. But what if we decide it's not fast enough anymore.<br>
                            For example, your websites starts giving timeouts to your users or maybe a faster code will bring more money for your company (or more data for your physicists).<br>
                            It's time for optimization!
                        </aside>
                    </section>
                    <section data-background="#fff">
                        <img src="./img/google-optimization.png">
                        <aside class="notes">
                            But how do you optimize your code ?<br>
                            Probably you need to follow some rules, so let's try to google that.<br>
                        </aside>
                    </section>
                    <section data-background="#fff">
                        <img src="./img/optimization-rules.png">
                        <aside class="notes">
                            Let's open the first link.<br>
                            Only 3 rules ? Wow, optimization might be easier than we expected!
                            Let's take a closer look at those rules.
                        </aside>
                    </section>
                    <section>
                        <ol>
                            <li>Don't</li>
                            <li>Don't...&nbsp;yet</li>
                            <li>Profile</li>
                        </ol>
                        <aside class="notes">
                            First rule of optimization: Don't. Ok, that was easy. Thank you for your attention. Are there any questions ?<br>
                            Ah, no wait, there is more.<br>
                            Those rules only look weird. So what does it mean 'Don't.
                            Well, 9 out of 10 times, you don't need the optimization, especially in the early part of your product's life.<br>
                            You might think it would be nice to optimize your code a bit, but first of all, you will waste time doing something that is not needed. You can get more benefits from getting a faster hardware of something if you want. Second of all, optimization comes with a cost. Sometimes it's only the time spend optimizing existing code. Sometimes you have to add even more time to fix, what you broke with you optimization. But also, the optimized code might not be as readable as it was in the first place. And maybe your code is running faster but uses more memory ? So unless you have real resons to optimize - don't do this.
                            If you know that you really need to optimize, then you can move to the second rule of optimization - don't do this yet. That would be my favorite rule - how I understand it is - first make sure your code works, then make sure you have good test suite and only then, start optimizing.<br>
                            I love this rule, it always reminds me how many times I have violated it. So many times I was in the middle of working on a more or less complex piece of code and then I started thinking: "Hey, I can change that piece of code and probably it will be faster - also I will save 2 lines of code".<br>
                            Did it end up well for me ?<br>
                            Nope. And it's not even because I broke some stuff. Well, quite often I ended up breaking something, but also, when I started jumping around the code, I forgot what exactly was I writing in the first place.<br> One way or another, it was causing confusion, pain and tears.<br>
                            Did it make my code faster ? I have no idea, cause I had nothing to compare it to! If I had written the whole function first and then improve it, I could measure it and see if it's better or worse now, but otherwise I could only guess.<br>
                            And that brings me to the last rules of optimization - Don't guess.<br>
                            Always profile your code before optimization. Human are terrible in predicting bottlenecks of the code. If you code is slow - profile it and see what takes the most time. Otherwise, you might end up spending time to rewrite part of your code just to make it 1% faster, while there are other parts of the system where you can gain much more improvements with less effort.
                        </aside>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Levels of optimization:</h3>
                        <ul>
                            <li>Design</li>
                            <li class="fragment">Algorithms and data structures</li>
                        </ul>
                        <aside class="notes">
                            Another important thing to note here is that there are various levels of optimization:<br>
                            Starting from the highest level, you have the design level optimization. Depending on the constrains and priorities of your system, you can optimize it by redesigning it. It might require rewriting parts or the whole application in a different programming language that might be faster, changing the type of a database or redesigning the architecture of your software to limit the number of DB queries etc.<br>
                            We are probably not interested in this kind of optimization today, as we are not going to rewrite something that we have been working very hard on in the past months or years. However, if you have some critical parts of the code that are run often, you can optimize it by rewriting it in C or C++. Because C is faster, you can get some good speed improvement for free. Well, not really for free - now you have to maintain Python AND C/C++ code in one project.

                            One level lower, we have algorithms and data structures. That's usually the second biggest improvement you can get after a complete redesign. Knowing different algorithms together with their complexity definitely helps creating good, fast software.
                            For example, you want to get a sum of numbers from 1 to N. The first idea might be a loop:
                        </aside>
                    </section>
                    <section>
                    </section>
                </section>

                <section>
                    <h2>Time it with %timeit</h2>
                    <pre><code class='python' data-trim data-noescape>
def a_function():
    print(42)
                    </pre></code>
                    <pre><code class='shell' data-trim data-noescape>
$ %timeit a_function
>>> xxx times, 5 ms per loop
                    </pre></code>
                    <aside class="notes">
                        In my examples, I have used the %timeit magic function that comes with IPython. It has some overhead over the standard timeit library, but it doesn't really matter - as long as we use the same method to measure execution time of different functions, we only need to know which method is faster and how many times.
                    </aside>
                </section>
                <!-- Counting elements in a list -->
                <section>
                <h4><span class="orange">#</span> Count elements in list</h4>
                    <pre><code class='python'># SLOW
how_many = 0
for element in BIG_LIST:
    how_many += 1
print how_many</pre></code>
                            <pre><code class='python'># FAST
print len(BIG_LIST)</pre></code>
                    <p>
                        For 1 000 000 elements it's <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        The fast version is <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        Let's start with something simple. Let's say you want to count a number of elements in a list. You can easily write a simple loop than increments a counter and there is nothing wrong with this code, except that it's slow. You can achieve the same results using the built-in function len(). And as you can see the speed improvement is quite huge.
                        So, try to use the built-in functions and functions from the standard library when you can.
                        <<< ADD a separate slide with the list of python 3.5.1 built-ins >>>
                        Python 3.5.1 contains 68 built-in variables [source](https://docs.python.org/3.5/library/functions.html) - you won't need all of them (I don't remember when was the list time - if ever - I used (xxx - find function names here), but it will take you just a moment to take a look at that list from time to time and keep it in the back of your head.
                    </aside>
                </section>
                <!-- Checking for True -->
                <section>
                <h4><span class="orange">#</span> Checking for True</h4>
                    <pre><code class='python' data-trim data-noescape>
if variable == True:
                    </pre></code>
                    <p>
                        <span class="bad">35.8 ns</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
if variable is True:
                    </pre></code>
                    <p>
                        <span class="bad">28.7 ns</span><br>
                        1.24 times faster
                    </p>
                    <pre><code class='python' data-trim data-noescape>
if variable:
                    </pre></code>
                    <p>
                        <span class="good">20.6 ns</span><br>
                        1.73 times faster
                    </p>
                    <aside class="notes">
                        Let's say you want to check if some variable or an expression is true. You can explicitly compare this variable to True, but unless you really want to check if a variable is really True (and not 0 or None)  you can simplify your condition to just 'if variable'. It will return True, unless the variable is False, None, 0, empty string, empty list or any other "Falsy" expression. And by doing that, your instruction get almost twice faster.
                    </aside>
                </section>
                <!-- Checking for False -->
                <section>
                <h4><span class="orange">#</span> Checking for False</h4>
                    <pre><code class='python' data-trim data-noescape>
if variable == False:
                    </pre></code>
                    <p>
                        <span class="bad">35.1 ns</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
if variable is False:
                    </pre></code>
                    <p>
                        <span class="bad">26.9 ns</span><br>
                        1.30 times faster
                    </p>
                    <pre><code class='python' data-trim data-noescape>
if not variable:
                    </pre></code>
                    <p>
                        <span class="good">19.8 ns</span><br>
                        1.77 times faster
                    </p>
                    <aside class="notes">
                        The same rule applies when checking for False, the fastest way to do this is to use 'if not variable', unless you really need to distinguish False from None, 0 or other Falsy values.
                    </aside>
                </section>
                <!-- Ask for permissions vs beg for forgiveness -->
                <section>
                <h4><span class="orange">#</span> Ask for permissions vs beg for forgiveness</h4>
                    <pre><code class='python' data-trim data-noescape>
class Foo(object):
    hello = 'world'
foo = Foo()
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
if hasattr(foo, 'hello'):
    foo.hello
                    </pre></code>
                    <p>
                        <span class="bad">149 ns</span><br>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
try:
    foo.hello
except AttributeError:
    pass
                    </pre></code>
                    <p>
                        <span class="good">43.1 ns</span><br>
                        3.5 times faster
                    </p>
                    <aside class="notes">
                        When you want to execute a piece of code, but you are not sure it will be successful (maybe some variables are not set or maybe performing a specific operation will throw as exception), so you want to protect yourself somehow. The first way you can do this is called 'Look before you leap' or ask for permission. What is means is that you check if all variables are set and everything is fine and then you perform you operations. Usually this checking is performed with the if statement.
                        However, there is a different approach that you could use - it's called "Beg for forgiveness". In this scenario, you perform your operation without checking the conditions, but in case you expect that something might break, you wrap you code in try/except block and catch the exceptions that were raised.
                        As you can see in this example, begging for forgiveness is 3,5 times faster.
                    </aside>
                </section>
                <!-- Ask for permissions vs beg for forgiveness 2 -->
                <section>
                <h4><span class="orange">#</span> Ask for permissions vs beg for forgiveness</h4>
                    <pre><code class='python' data-trim data-noescape>
if (hasattr(foo, 'foo') and hasattr(foo, 'bar')
    and hasattr(foo, 'baz')):
    foo.foo
    foo.bar
    foo.baz
                    </pre></code>
                    <p>
                        vs
                    </p>
                    <pre><code class='python' data-trim data-noescape>
try:
    foo.foo
    foo.bar
    foo.baz
except AttributeError:
    pass
                    </pre></code>
                    <p>
                        <span class="bad">401 ns</span> vs <span class="good">110 ns</span><br>
                        3.64 times faster
                    </p>
                    <aside class="notes">
                        But it gets even better if you are checking for more conditions.
                        Here, we are checking if 3 attributes are available. Asking for permissions is still slower and now it gets more difficult to read.
                        Following the beg for forgiveness principle will result in faster and more readable code
                        So, is asking for forgiveness instead of checking the permissions always the best choice ?
                    </aside>
                </section>
                <!-- Ask for permissions vs beg for forgiveness 3 -->
                <section>
                <h4><span class="orange">#</span> Ask for permissions vs beg for forgiveness</h4>
                    <pre><code class='python' data-trim data-noescape>
class Bar(object):
    pass
bar = Bar()
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
if hasattr(bar, 'hello'):
    bar.hello
                    </pre></code>
                    <p>
                        <span class="good">428 ns</span><br>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
try:
    bar.hello
except AttributeError:
    pass
                    </pre></code>
                    <p>
                        <span class="bad">536 ns</span><br>
                        25% slower
                    </p>
                    <aside class="notes">
                        Well, not really. The exception handling is still quite expensive performance wise.
                        If the object doesn't have the attribute we are looking for, begging for forgiveness will be slower than asking for permissions.
                        So as a rule of thumb, you can use the 'Ask for permissions' way if you know that it's very probably that there will be some uninitialized variables or other problems.
                        Otherwise if you are expecting your code to run smoothly most of the time (for example, you are fetching some files from the internet and you are expecting that it will work, unless there is no internet connection) using try/except will be the faster and quite often cleaner way to go.
                        But again, I strongly advise you to measure both solutions to see which one is faster in your scenario.
                    </aside>
                </section>
                <!-- Ask for permissions vs beg for forgiveness 4 -->
                <section>
                <h4><span class="orange">#</span> Ask for permissions vs beg for forgiveness</h4>
                    <p>Find an example of using dict.get() function to best faster and better than ask for forgiveness/permissions</p>
                    <aside class="notes">
                        Quite common use case for this kind of lookup happens with the dictionaries. Let's say we have a dictionary containing square value of the first 1 million numbers. For an arbitrary number, we want to get it's square value or empty string, if there is no emtry in our dictionary.
                        As you can see, begging for forgiveness is almost twice faster than asking for permission.
                        But we can do better than this. Dictionaries have a get method, that you should use in a case like that.
                    </aside>
                </section>
                <!-- END Execute operation 1000 times in a function than a function 1000 times -->
                <section>
                <h4><span class="orange">#</span> Execute function 1000 times or execute an operation 1000 times in a function ?</h4>
                    <pre><code class='python' data-trim data-noescape>
def square(number):
    return number**2
squares = [square(i) for i in range(1000)]
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
def compute_squares():
    return [i**2 for i in range(1000)]
                    </pre></code>
                    <p>
                        <span class="bad">399 µs</span> vs <span class="good">314 µs</span><br>
                         27% faster
                    </p>
                    <aside class="notes">
                        If you want to perform some kind of operation on a large set of data, your first idea might be to write a function that performs said operation and then apply this function on the set of data. However, it's faster to perform those 1000 operations inside a function instead of calling a function 1000 times.
                    </aside>
                </section>
                <!-- Create a string from a list -->
                <section>
                <h4><span class="orange">#</span> Create a string from a list</h4>
                    <pre><code class='python' data-trim data-noescape>
# Create a list of 1000 words:
LIST = ['word'] * 1000
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
result = ''
for word in LIST:
    result += word
                    </pre></code>
                    <p>vs</p>
                    <pre><code class='python' data-trim data-noescape>
result = ''.join(LIST)
                    </pre></code>
                    <p>
                        10000 loops, best of 3: 94 µs per loop
                        100000 loops, best of 3: 8.54 µs per loop

                        <span class="bad">94 µs</span> vs <span class="good">8.54 µs</span><br>
                        11 times faster
                    </p>
                    <aside class="notes">
                        Let's talk about string for now. If you have a list of strings and want to concatenate them into one string, using a loop is not the best idea. Instead, you can use the join function, that will be much faster (and clearer to understand). Here, for a list of 1000 words, the join function is 11 times faster. I have also tested it with longer words and even though the difference got lower (for 1000 words of 600 characters, join was 'only' twice as fast), join function is still a clear winner here.
                    </aside>
                </section>
                <!-- String formatting is faster than string concatenation -->
                <section>
                <h4><span class="orange">#</span> String formatting or string concatenation ?</h4>
                <h2>This is not working, find better example: https://wiki.python.org/moin/PythonSpeed/PerformanceTips#String_Concatenation</h2>
                    <pre><code class='python' data-trim data-noescape>
word1 = 'Hello'
word2 = 'world'
word3 = 'from'
word4 = 'EuroPython'
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
"This is:" + word1 + word2 + word3 + word4 + "!"
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
"This is:%s%s%s%s!" % (word1, word2, word3, word4)

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                    1000000 loops, best of 3: 369 ns per loop

                        In case you are trying to concatenate just a few strings, not a whole list, you are also better of with using string formatting, instead of concatenation operator.
                    </aside>
                </section>
                <!-- List sorting is faster in place -->
                <section>
                <h4><span class="orange">#</span> List sorting</h4>
                    <pre><code class='python' data-trim data-noescape># SETUP
alist = [random.randint(1,100) for _ in range(1000000)]
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        List sorting is faster when you do this in place with list.sort() instead of calling sorted method on a list.
                    </aside>
                </section>
                <!-- Filter a list -->
                <section>
                <h4><span class="orange">#</span> Filter list</h4>
                    <pre><code class='python' data-trim data-noescape>
# SLOW
output = []
for element in MILLION_ELEMENTS:
    if element % 2:
        output.append(element)
                    </pre></code>
                    <p>
                        <span class="bad">107 ms</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
# FAST?
list(filter(lambda x: x % 2, MILLION_ELEMENTS))
                    </pre></code>
                    <p>
                        <span class="bad">168 ms</span>
                    </p>
                    <pre><code class='python' data-trim data-noescape>
# FAST!
[item for item in MILLION_ELEMENTS if item % 2]
                    </pre></code>
                    <p>
                        <span class="good">80.9 ms</span>
                    </p>
                    <p>
                        35% faster
                    </p>
                    <aside class="notes">
                        Let's say you want to filter a list of 1 million elements and select only those, that are matching some condition.
                        The naive version would be to use for loop, but I already showed you that in most cases, for loops are bad.
                        You can use the built-in filter function instead. In Python2, filter was returning the list directly. In Python3, it's returning an iterator, so I need to explicitly convert the results of filter function to a list to get the same results as in case of the loop.
                        This conversion impacts the performance, but even without some overhead for list function, you can see that filter performs much slower.
                        Why does this happen ? Well, the fact that filter is now returning an iterator is a good suggestion that this is a wrong use case for filter function.
                        If we want to get the whole list as a result, the better idea is to use list comprehension. It's around 35% faster than the for loop and - at least for me - it looks much better.
                    </aside>
                </section>
                <!-- Lambda vs def -->
                <section>
                <h4><span class="orange">#</span> Lambda vs def</h4>
                    <p>Def:</p>
                    <pre><code class='python' data-trim data-noescape>
def greet_def(name):
    return 'Hello {}!'.format(name)
                    </pre></code>
                    <p>Lambda:</p>
                    <pre><code class='python' data-trim data-noescape>
greet_l = lambda name: 'Hello {}!'.format(name)
                    </pre></code>
                    <p>Compare:</p>
                    <pre><code class='python' data-trim data-noescape>
>>> %timeit greet_def('Tom')
1000000 loops, best of 3: 329 ns per loop
>>> %timeit greet_l('Tom')
1000000 loops, best of 3: 332 ns per loop
                    </pre></code>
                    <aside class="notes">
                        Let's take a look at different ways of defining functions in Python. The most common way to create a function is with def keyword. The other way is to declare an anonymous function with lambda. If you assign this lambda to a variable it will act in the same way as function created with def keyword.
                        So let's see which version is faster.
                        Well, actually they are both equally fast.
                        Why ? Because both version exactly the same thing.
                        We can see that even better when disassembling the code of both function.
                    </aside>
                </section>
                <!-- Lambda vs def contd.-->
                <section>
                <h4><span class="orange">#</span> Lambda vs def</h4>
                    <pre><code class='python' data-trim data-noescape>
>>> dis.dis(greet_def)
 0 LOAD_CONST    1 ('Hello {}!')
 3 LOAD_ATTR     0 (format)
 6 LOAD_FAST     0 (name)
 9 CALL_FUNCTION 1 (1 positional, 0 keyword pair)
12 RETURN_VALUE
                    </pre></code>
                    <pre><code class='python' data-trim data-noescape>
>>> dis.dis(greet_l)
 0 LOAD_CONST    1 ('Hello {}!')
 3 LOAD_ATTR     0 (format)
 6 LOAD_FAST     0 (name)
 9 CALL_FUNCTION 1 (1 positional, 0 keyword pair)
12 RETURN_VALUE
                    </pre></code>
                    <small><a href='http://stackoverflow.com/questions/29804774/why-is-lambda-expression-necessary-in-this-example-python'>Stack Overflow on when lambda might be necessary</a></small>
                    <aside class="notes">
                        So is there any difference ?
                        Well, if your function has more than one line, then you can't use lambda.
                        Also, you can't really put documentation inside lambda function.
                        And if you have PEP-8 enabled in you code editor, it will complain each time you try to assign lambda to a variable.
                        And he is right, lambda works really nice when you need a simple one-liner callback for functions, especially for functions like filter, map or reduce.
                        There are also some quite narrow use cases when it might be necessary to use the lambda instead of def as a callback - if you want to read more, I'm linking a stack overflow question with that problem.
                        However, for any other case, I would use def. It's much cleaner, you can document it properly and the performance is the same.
                    </aside>
                </section>
                <!-- [] vs list() and {} vs dict() -->
                <section>
                <h4><span class="orange"></span>[] and {}</h4>
                    <div>
                        <div class='left'>
                            <pre><code class='python' data-trim data-noescape>
list()
                            </pre></code>
                            <p>
                                <span class="bad">104 ns</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>
[]
                            </pre></code>
                            <p>
                                <span class="good">22.5 ns</span>
                            </p>
                            <p>
                                4.6 times faster
                            </p>
                        </div>
                        <div class='right'>
                            <pre><code class='python' data-trim data-noescape>
dict()
                            </pre></code>
                            <p>
                                <span class="bad">161 ns</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>
{}
                            </pre></code>
                            <p>
                                <span class="good">93 ns</span>
                            </p>
                            <p>
                                1.7 times faster
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        There are 2 ways you can create an empty list or a dictionary. You can either call a function for that, or you can simply use the literal syntax.
                        As you can see, using the literal syntax is way faster.
                        Let's take a quick look, why this happens.
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- XXXXXXXXXX -->
                <section>
                <h4><span class="orange">#</span> XXXXXXXXXX</h4>
                    <pre><code class='python' data-trim data-noescape># SLOW

                    </pre></code>
                    <pre><code class='python' data-trim data-noescape># FAST

                    </pre></code>
                    <p>
                        XXXXXXX <span class="bad">26.5 ms</span> vs <span class="good">96.7 ns</span><br>
                        XXXXXXXX <span class="good">274 000</span> times faster
                    </p>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
                <!-- SPLIT DIV -->
                <section>
                <h4><span class="orange">#</span> SPLIT DIV </h4>
                    <div>
                        <div class='left'>
                            <pre><code class='python' data-trim data-noescape>

                            </pre></code>
                            <p>
                                <span class="bad">xxxxxx</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>

                            </pre></code>
                            <p>
                                <span class="good">xxxxxx</span>
                            </p>
                            <p>
                                xxxxxxxxx
                            </p>
                        </div>
                        <div class='right'>
                            <pre><code class='python' data-trim data-noescape>

                            </pre></code>
                            <p>
                                <span class="bad">xxxxxxxx</span>
                            </p>
                            <pre><code class='python' data-trim data-noescape>

                            </pre></code>
                            <p>
                                <span class="good">xxxxxxxx</span>
                            </p>
                            <p>
                                xxxxxxxxxx
                            </p>
                        </div>
                    </div>
                    <aside class="notes">
                        xxxxxxxxxxxxxxxxx
                    </aside>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                history: true,
                slideNumber: 'c/t',

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>
